[{"path":[]},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement dansmith01@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://cmmr.github.io/webqueue/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://cmmr.github.io/webqueue/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 webqueue authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Handler","text":"handler function responsible transforming request (req) response (resp).","code":"library(webqueue)  handler <- function (req) {   # <request processing code>   return (resp) }"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"http-request","dir":"Articles","previous_headings":"","what":"HTTP Request","title":"Handler","text":"HTTP request : .list(req) : Also good know: req bare environment. parent.env(req) emptyenv().","code":"POST /dir/file.txt?c=world HTTP/1.1 Host: localhost:8080 User-Agent: httr2/1.1.0 r-curl/6.2.0 libcurl/8.10.1 Accept: */* Accept-Encoding: deflate, gzip Cookie: token=abc x-session-id: 123 Content-Type: application/json Content-Length: 25  {\"a\":[1,1,3],\"b\":\"hello\"} list(   ARGS           = list(a = c(1L, 1L, 3L), b = \"hello\", c = \"world\"),    COOKIES        = list(token = \"abc\"),        HEADERS        = c(     `content-type` = \"application/json\",      host           = \"localhost:8080\",          `user-agent`   = \"httr2/1.1.0 r-curl/6.2.0 libcurl/8.10.1\",          `x-session-id` = \"123\" ),    PATH_INFO      = \"/dir/file.txt\",    REMOTE_ADDR    = \"127.0.0.1\",    REQUEST_METHOD = \"POST\",    SERVER_NAME    = \"127.0.0.1\",        SERVER_PORT    = \"8080\" )"},{"path":[]},{"path":[]},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"a-list-will-be-encoded-as-json-","dir":"Articles","previous_headings":"HTTP Response > Simple","what":"A list will be encoded as JSON.","title":"Handler","text":"","code":"wq <- WebQueue$new(handler = ~{ list(r = 2, d = 2) })  httr2::request('http://localhost:8080') |>   httr2::req_perform() |>   httr2::resp_raw() #> HTTP/1.1 200 OK #> Date: Thu, 13 Feb 2025 21:31:44 GMT #> Content-Type: application/json; charset=utf-8 #> Content-Encoding: gzip #> Transfer-Encoding: chunked #>  #> {\"r\":[2],\"d\":[2]}  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"a-character-vector-will-be-concatenated-together-","dir":"Articles","previous_headings":"HTTP Response > Simple","what":"A character vector will be concatenated together.","title":"Handler","text":"","code":"wq <- WebQueue$new(handler = ~{ LETTERS })  httr2::request('http://localhost:8080') |>   httr2::req_perform() |>   httr2::resp_raw() #> HTTP/1.1 200 OK #> Date: Thu, 13 Feb 2025 21:31:44 GMT #> Content-Type: text/html; charset=utf-8 #> Content-Encoding: gzip #> Transfer-Encoding: chunked #>  #> ABCDEFGHIJKLMNOPQRSTUVWXYZ  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"an-integer-will-be-interpreted-as-an-http-status-code-","dir":"Articles","previous_headings":"HTTP Response > Simple","what":"An integer will be interpreted as an HTTP status code.","title":"Handler","text":"","code":"wq <- WebQueue$new(handler = ~{ 404L })  httr2::request('http://localhost:8080') |>   httr2::req_error(is_error = function (resp) FALSE) |>   httr2::req_perform() |>   httr2::resp_raw() #> HTTP/1.1 404 Not Found #> Date: Thu, 13 Feb 2025 21:31:44 GMT #> Content-Encoding: gzip #> Transfer-Encoding: chunked #>  #> Not Found  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"intermediate","dir":"Articles","previous_headings":"HTTP Response","what":"Intermediate","title":"Handler","text":"construct complex HTTP response, use response(), header(), cookie(), js_obj() functions. Important functions handler’s environment default. Either call webqueue:: prefix, create WebQueue packages = 'webqueue'.","code":"wq <- WebQueue$new(   packages = 'webqueue',   handler  = ~{     body  <- list(data = js_obj(list()))     token <- cookie(token = 'randomstring123')     uid   <- header('x-user-id' = 100, expose = TRUE)     response(body, token, uid)   })  httr2::request('http://localhost:8080') |>   httr2::req_perform() |>   httr2::resp_raw() #> HTTP/1.1 200 OK #> Date: Thu, 13 Feb 2025 21:31:44 GMT #> Set-Cookie: token=randomstring123 #> x-user-id: 100 #> Access-Control-Expose-Headers: x-user-id #> Content-Type: application/json; charset=utf-8 #> Content-Encoding: gzip #> Transfer-Encoding: chunked #>  #> {\"data\":{}}  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"advanced","dir":"Articles","previous_headings":"HTTP Response","what":"Advanced","title":"Handler","text":"bypass webqueue’s response formatting, wrap response () indicate passed httpuv -. See help page httpuv::startServer() description expected list(status, headers, body) object. Although says body = NULL fine, found case.","code":"wq <- WebQueue$new(   handler  = ~{     status  <- 200L     body    <- '{\"data\":{}}'     headers <- list(       'Set-Cookie' = 'token=randomstring123',       'x-user-id' = '100',       'Access-Control-Expose-Headers' = 'x-user-id',       'Content-Type' = 'application/json; charset=utf-8' )     I(list(body = body, status = status, headers = headers))   })  httr2::request('http://localhost:8080') |>   httr2::req_perform() |>   httr2::resp_raw() #> HTTP/1.1 200 OK #> Date: Thu, 13 Feb 2025 21:31:44 GMT #> Set-Cookie: token=randomstring123 #> x-user-id: 100 #> Access-Control-Expose-Headers: x-user-id #> Content-Type: application/json; charset=utf-8 #> Content-Encoding: gzip #> Transfer-Encoding: chunked #>  #> {\"data\":{}}  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"prepost-modifications","dir":"Articles","previous_headings":"","what":"Pre/Post Modifications","title":"Handler","text":"handler function evaluated background process, access variables foreground process. However, opportunities make modifications foreground process req passed handler, resp returned handler. Important callbacks evaluated foreground process. Therefore, ensure execute quickly bottleneck request handling.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"request-parsing","dir":"Articles","previous_headings":"Pre/Post Modifications","what":"Request Parsing","title":"Handler","text":"parse function called req (environment). Aside req$ARGS req$COOKIES, req exactly received httpuv. callback, extraneous httpuv fields removed req minimize amount data sent background process. modifications req persistent. stop request callback, use stop(). return value parse ignored.","code":"parse <- local({   counter <- 1   function (req) {     req$counter <- counter     counter <<- counter + 1   } })  wq <- WebQueue$new(   handler = function (req) { req$counter },   parse   = parse )  RCurl::getURL('http://localhost:8080') #> [1] \"1\"  RCurl::getURL('http://localhost:8080') #> [1] \"2\"  RCurl::getURL('http://localhost:8080') #> [1] \"3\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"job-hooks","dir":"Articles","previous_headings":"Pre/Post Modifications","what":"Job Hooks","title":"Handler","text":"parse called, resulting req added Job. Callbacks triggered Job enters 'created', 'submitted', 'queued', 'starting' states. hooks can edit job req environment objects. modifications job req persistent. stop request callback, use job$stop(). return value hooks ignored.","code":"hooks <- list()  # Request received hooks$created <- function (job) { job$req$ARGS$a <- 1 }  # Submitted to the Queue hooks$submitted <- function (job) { job$req$ARGS$b <- 2 }  # Accepted by the Queue hooks$queued <- function (job) { job$req$ARGS$c <- 3 }  # Last chance to edit hooks$starting <- function (job) { job$req$ARGS$d <- 4 }   wq <- WebQueue$new(   handler = function (req) { req$ARGS },   hooks   = hooks )  cat(RCurl::getURL('http://localhost:8080')) #> {\"a\":[1],\"b\":[2],\"c\":[3],\"d\":[4]}  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/handler.html","id":"response-reformatting","dir":"Articles","previous_headings":"Pre/Post Modifications","what":"Response Reformatting","title":"Handler","text":"reformat function lets edit resp immediately ’s returned handler (webqueue httpuv try interpret HTTP response). can access job req environments. However, changes made req handler reflected . Important call job$result within reformat function - trigger infinite recursion. Instead, access job$output. stop request callback, use job$stop(). return value used new resp.","code":"reformat <- function (job) {   paste0('<h1>', job$output, '<\/h1>') }  wq <- WebQueue$new(   handler  = ~{ 'Hello' },   reformat = reformat )  RCurl::getURL('http://localhost:8080') #> [1] \"<h1>Hello<\/h1>\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Interrupts","text":"Interrupts webqueue fall three categories: Timeout - set request starts processing. Replacement - later request replaces earlier one. Custom - code calls Job’s $stop() method.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"requests-vs-jobs","dir":"Articles","previous_headings":"Overview","what":"Requests vs Jobs","title":"Interrupts","text":"request (req) environment data sent web browser web server. Job (job) R6 object containing single req along parameters processing . useful elements : req$ARGS req$COOKIES req$PATH_INFO req$REMOTE_ADDR job$result job$timeout job$() job$stop() Interrupts always defined Job level.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Interrupts","text":"interrupt job within handler, call stop() cli_abort() usual, return (webqueue::response()) send informative message back.","code":"library(webqueue) library(RCurl)  handler <- function (req) {   args <- req$ARGS                         # POST/GET parameters   if (!is.null(args$s)) Sys.sleep(args$s)  # sleep for `s` seconds   if (!is.null(args$x)) return (args$x)    # return `x` if present   return ('hello')                         # default to 'hello' }"},{"path":[]},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"basic","dir":"Articles","previous_headings":"Timeout","what":"Basic","title":"Interrupts","text":"Let’s start limiting Jobs 1 second.","code":"wq <- WebQueue$new(handler, timeout = 1)  getURL('http://localhost:8080') #> [1] \"hello\"  getURL('http://localhost:8080?x=hi') #> [1] \"hi\"  getURL('http://localhost:8080?s=3') #> [1] \"timeout: total runtime exceeded 1 second\\n\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"per-state","dir":"Articles","previous_headings":"Timeout","what":"Per State","title":"Interrupts","text":"Setting timeout = 1 shorthand timeout = c(total = 1), starts clock soon job created. jobs likely wait long time running, might consider setting timeout = c(running = 1) starts clock job actually begins running. , set timeout = c(running = 1, queued = 60) also set limit long job can spend waiting queue. See jobqueue::Job reference page information standard Job states.","code":"wq <- WebQueue$new(handler, timeout = c(queued = 1))  getURL('http://localhost:8080?s=3')  # spends 3 seconds in 'running' state #> [1] \"hello\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"per-request","dir":"Articles","previous_headings":"Timeout","what":"Per Request","title":"Interrupts","text":"Perhaps pages website need different time limit.","code":"timeout <- function (job) {   ifelse(job$req$PATH_INFO == '/compute', 5, 1) }  wq <- WebQueue$new(handler, timeout = timeout)  getURL('http://localhost:8080/compute?s=3') #> [1] \"hello\"  getURL('http://localhost:8080?s=3') #> [1] \"timeout: total runtime exceeded 1 second\\n\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"replacement","dir":"Articles","previous_headings":"","what":"Replacement","title":"Interrupts","text":"Use stop_id field run recent request given hash. instance, session id (sid) can use request hash.","code":"stop_id <- function (job) { job$req$ARGS$sid }  wq <- WebQueue$new(handler, stop_id = stop_id)  # Fetch three URLs at the same time. jq <- jobqueue::Queue$new(workers = 3L) r1 <- jq$run({ RCurl::getURL('http://localhost:8080?sid=1&s=1&x=first')  }) r2 <- jq$run({ RCurl::getURL('http://localhost:8080?sid=1&s=1&x=second') }) r3 <- jq$run({ RCurl::getURL('http://localhost:8080?sid=1&s=1&x=third')  })  r1$result #> [1] \"superseded: duplicated stop_id\\n\"  r2$result #> [1] \"superseded: duplicated stop_id\\n\"  r3$result #> [1] \"third\"  jq$stop() wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"cancel","dir":"Articles","previous_headings":"Replacement","what":"Cancel","title":"Interrupts","text":"can also send dummy request appropriate stop_id hash cancel actual request.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"custom","dir":"Articles","previous_headings":"","what":"Custom","title":"Interrupts","text":"Anywhere provide function (job), can examine Job request, call job$stop() needed.","code":""},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"ip-filter","dir":"Articles","previous_headings":"Custom","what":"IP Filter","title":"Interrupts","text":"ignore requests certain IP addresses: Note: reality, ’d want use webqueue::WebQueue$new(onHeaders) particular task efficiently.","code":"ip_check <- function (job) {   ip <- job$req$REMOTE_ADDR   if (!startsWith(ip, '192.168.'))     job$stop(paste('Unauthorized IP Address:', ip)) }  wq <- WebQueue$new(handler, hooks = list(created = ip_check))  getURL('http://localhost:8080') #> [1] \"interrupt: Unauthorized IP Address: 127.0.0.1\\n\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"queue-limit","dir":"Articles","previous_headings":"Custom","what":"Queue Limit","title":"Interrupts","text":"job assigned Queue, can access list jobs currently queued running. , ’ll refuse add 2 jobs queue .","code":"qlimit <- function (job) {   if (length(job$queue$jobs) > 2)     job$stop('Queue is too full.') }  wq <- WebQueue$new(handler, hooks = list(queued = qlimit))  # Fetch three URLs at the same time. jq <- jobqueue::Queue$new(workers = 3L) r1 <- jq$run({ RCurl::getURL('http://localhost:8080?s=1') }) r2 <- jq$run({ RCurl::getURL('http://localhost:8080?s=1') }) r3 <- jq$run({ RCurl::getURL('http://localhost:8080?s=1') })  r1$result #> [1] \"hello\"  r2$result #> [1] \"hello\"  r3$result #> [1] \"interrupt: Queue is too full.\\n\"  jq$stop() wq$stop()"},{"path":"https://cmmr.github.io/webqueue/articles/interrupts.html","id":"stop-other-jobs","dir":"Articles","previous_headings":"Custom","what":"Stop Other Jobs","title":"Interrupts","text":"Suppose admin needs stop jobs particular user.","code":"stop_user <- function (job) {    stop_uid <- job$req$ARGS$stop   if (!is.null(stop_uid)) {        for (j in job$queue$jobs)       if (j$req$ARGS$u == stop_uid)         j$stop('Stopped by admin.')          job$output <- 'done'   } }  wq <- WebQueue$new(handler, hooks = list(queued = stop_user))  # Fetch three URLs at the same time. jq <- jobqueue::Queue$new(workers = 3L) r1 <- jq$run({ RCurl::getURL('http://localhost:8080?u=1&s=10')   }) r2 <- jq$run({ RCurl::getURL('http://localhost:8080?u=1&s=10')   }) r3 <- jq$run({ RCurl::getURL('http://localhost:8080?u=2&stop=1') })  r1$result #> [1] \"interrupt: Stopped by admin.\\n\"  r2$result #> [1] \"interrupt: Stopped by admin.\\n\"  r3$result #> [1] \"done\"  jq$stop() wq$stop()"},{"path":"https://cmmr.github.io/webqueue/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/webqueue/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). webqueue: HTTP Server Using Multiple CPU Cores. R package version 0.0.1.9014, https://github.com/cmmr/webqueue, https://cmmr.github.io/webqueue/.","code":"@Manual{,   title = {webqueue: HTTP Server Using Multiple CPU Cores},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 0.0.1.9014, https://github.com/cmmr/webqueue},   url = {https://cmmr.github.io/webqueue/}, }"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"webqueue","dir":"","previous_headings":"","what":"HTTP Server Using Multiple CPU Cores","title":"HTTP Server Using Multiple CPU Cores","text":"goal webqueue process HTTP requests interruptible background processes. Use cases: Prevent user-submitted jobs excessively hogging compute resources. Stop tasks longer needed.","code":""},{"path":"https://cmmr.github.io/webqueue/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"HTTP Server Using Multiple CPU Cores","text":"","code":"# Install the latest stable version from CRAN: install.packages(\"webqueue\")  # Or the development version from GitHub: install.packages(\"pak\") pak::pak(\"cmmr/webqueue\")"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"HTTP Server Using Multiple CPU Cores","text":"","code":"library(webqueue)  wq <- WebQueue$new(~{ 'Hello world!\\n' })  readLines('http://localhost:8080') #> [1] \"Hello world!\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"query-parameters","dir":"","previous_headings":"","what":"Query Parameters","title":"HTTP Server Using Multiple CPU Cores","text":"Accepts GET POST parameters.","code":"wq <- WebQueue$new(~{ jsonlite::toJSON(.$ARGS) })  cat(RCurl::getURL('http://localhost:8080?myvar=123')) #> {\"myvar\":[\"123\"]}  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"interrupting-requests","dir":"","previous_headings":"","what":"Interrupting Requests","title":"HTTP Server Using Multiple CPU Cores","text":"strength webqueue ability cleanly abort request point. See vignette('interrupts') detailed examples.","code":""},{"path":"https://cmmr.github.io/webqueue/index.html","id":"set-a-time-limit","dir":"","previous_headings":"Interrupting Requests","what":"Set a time limit","title":"HTTP Server Using Multiple CPU Cores","text":"","code":"wq <- WebQueue$new(   handler = ~{ Sys.sleep(.$ARGS$s); 'Hello world!' },    timeout = 1 )  RCurl::getURL('http://localhost:8080?s=2') #> [1] \"timeout: total runtime exceeded 1 second\\n\"  RCurl::getURL('http://localhost:8080?s=0') #> [1] \"Hello world!\"  wq$stop()"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"merge-duplicate-requests","dir":"","previous_headings":"Interrupting Requests","what":"Merge duplicate requests","title":"HTTP Server Using Multiple CPU Cores","text":"","code":"wq <- WebQueue$new(   handler = function (req) { Sys.sleep(1); req$ARGS$x },    copy_id = function (job) job$req$PATH_INFO ) # ^^^^^^^   `copy_id` will be '/a' or '/b'  # Fetch two URLs at the same time. '/b' path is merged. jq <- jobqueue::Queue$new(workers = 3L)$wait()   # vv a1 <- jq$run({ RCurl::getURL('http://localhost:8080/a?x=first') }) b1 <- jq$run({ RCurl::getURL('http://localhost:8080/b?x=second') }) b2 <- jq$run({ RCurl::getURL('http://localhost:8080/b?x=third') })  dput(c(a1 = a1$result, b1 = b1$result, b2 = b2$result)) #> c(a1 = \"first\", b1 = \"second\", b2 = \"second\")  jq$stop() wq$stop()"},{"path":"https://cmmr.github.io/webqueue/index.html","id":"stop-duplicate-requests","dir":"","previous_headings":"Interrupting Requests","what":"Stop duplicate requests","title":"HTTP Server Using Multiple CPU Cores","text":"","code":"wq <- WebQueue$new(   handler = function (req) { Sys.sleep(1); req$ARGS$x },    stop_id = function (job) job$req$PATH_INFO ) # ^^^^^^^   `stop_id` will be '/a' or '/b'  # Fetch three URLs at the same time. '/b' path is stopped. jq <- jobqueue::Queue$new(workers = 3L)$wait()   # vv a1 <- jq$run({ RCurl::getURL('http://localhost:8080/a?x=first') }) b1 <- jq$run({ RCurl::getURL('http://localhost:8080/b?x=second') }) b2 <- jq$run({ RCurl::getURL('http://localhost:8080/b?x=third') })  dput(c(a1 = a1$result, b1 = b1$result, b2 = b2$result)) #> c(a1 = \"first\", b1 = \"superseded: duplicated stop_id\\n\", b2 = \"third\")  jq$stop() wq$stop()"},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":null,"dir":"Reference","previous_headings":"","what":"Queues and Services HTTP Requests — WebQueue","title":"Queues and Services HTTP Requests — WebQueue","text":"Connects 'httpuv' 'jobqueue' R packages.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Queues and Services HTTP Requests — WebQueue","text":"url URL server available.","code":""},{"path":[]},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Queues and Services HTTP Requests — WebQueue","text":"WebQueue$new() WebQueue$print() WebQueue$stop()","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Queues and Services HTTP Requests — WebQueue","text":"Creates httpuv::WebServer requests handled jobqueue::Queue.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Queues and Services HTTP Requests — WebQueue","text":"","code":"WebQueue$new(   handler,   host = \"0.0.0.0\",   port = 8080L,   parse = NULL,   globals = list(),   packages = NULL,   init = NULL,   max_cpus = availableCores(),   workers = ceiling(max_cpus * 1.2),   timeout = NULL,   hooks = NULL,   reformat = NULL,   stop_id = NULL,   copy_id = NULL,   bg = TRUE,   quiet = FALSE,   onHeaders = NULL,   staticPaths = NULL,   staticPathOptions = NULL )"},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Queues and Services HTTP Requests — WebQueue","text":"handler function (request) run background worker process. returned value passed reformat, sent server's response web client. host string valid IPv4 address owned server, '0.0.0.0' listen IP addresses. port number integer indicates server port listened . Note Unix-like systems including Linux macOS, port numbers smaller 1024 require root privileges. parse function (req) run foreground process transform HTTP request prior passing handler. req environment object provided 'httpuv', amended $ARGS $COOKIES. Edit req place /signal error. globals list variables add handler's evaluation environment. packages Character vector package names load workers. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages. Returned value ignored. max_cpus Total number CPU cores can reserved running Jobs (sum(cpus)). enforce limits actual CPU utilization. workers many background Worker processes start. Set max_cpus enable interrupted workers quickly swapped standby Workers replacement Worker boots . timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. Example: timeout = c(total = 2.5, running = 1). hooks list functions run Job state changes, form hooks = list(created = function (job) {...}, done = ~{...}). See vignette('hooks'). reformat function (job) run foreground process transform output handler. default, reformat = NULL, essentially function (job) { job$output }. stop_id function (job). two Jobs generate value function, earlier Job aborted. returned value NULL, Jobs stopped. copy_id function (job). two Jobs generate value function, later Job clone output earlier Job. returned value NULL, Jobs cloned. bg /run server. TRUE: separate R process. FALSE: blocking current R process. NULL: non-blocking current R process. quiet TRUE, suppress error messages starting 'httpuv' server. onHeaders function (request) triggered headers received 'httpuv'. Return NULL continue normal processing request, Rook response send response, stop processing request, ask client close connection. (can used implement upload size limits, example.) staticPaths named list paths served without invoking handler() onHeaders(). name one URL path, value either string referring local path, object created httpuv::staticPath() function. staticPathOptions set default options use serving static paths. set NULL, use result calling httpuv::staticPathOptions() arguments.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Queues and Services HTTP Requests — WebQueue","text":"WebQueue object.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Queues and Services HTTP Requests — WebQueue","text":"Print method WebQueue.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Queues and Services HTTP Requests — WebQueue","text":"","code":"WebQueue$print(...)"},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Queues and Services HTTP Requests — WebQueue","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Queues and Services HTTP Requests — WebQueue","text":"Shuts WebQueue associated subprocesses. Stopped Jobs $output set object class <interrupt/condition>","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Queues and Services HTTP Requests — WebQueue","text":"","code":"WebQueue$stop(reason = \"server stopped\")"},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Queues and Services HTTP Requests — WebQueue","text":"reason brief message condition object.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Queues and Services HTTP Requests — WebQueue","text":"WebQueue, invisibly.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/WebQueue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Queues and Services HTTP Requests — WebQueue","text":"","code":"if (FALSE) {        svr <- WebQueue$new(         handler = function (request) 'Hello World!',         host    = '127.0.0.1',         port    = 8080L )     }"},{"path":"https://cmmr.github.io/webqueue/reference/cookie.html","id":null,"dir":"Reference","previous_headings":"","what":"Assemble an HTTP cookie. — cookie","title":"Assemble an HTTP cookie. — cookie","text":"See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie -depth description parameter's purpose.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/cookie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assemble an HTTP cookie. — cookie","text":"","code":"cookie(   ...,   max_age = NULL,   domain = NULL,   path = NULL,   same_site = \"Lax\",   secure = FALSE,   http_only = FALSE,   partitioned = FALSE,   name = ...names(),   value = ..1 )"},{"path":"https://cmmr.github.io/webqueue/reference/cookie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assemble an HTTP cookie. — cookie","text":"... single key-value pair. max_age number seconds expiration. Omit create session cookie. Inf mapped 34560000L (400 days). domain Send requests host. path Send requests path. same_site 'Strict', 'Lax', 'None'. secure required 'None'. secure send HTTPS. http_only Disallow javascript access. partitioned Use partitioned storage. secure required. name Explicitly set name (key) key-value pair. value Explicitly set value key-value pair.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/cookie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assemble an HTTP cookie. — cookie","text":"'header' object can passed response().","code":""},{"path":"https://cmmr.github.io/webqueue/reference/cookie.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assemble an HTTP cookie. — cookie","text":"","code":"library(webqueue)          cookie(xyz = 123, max_age = 3600, http_only = TRUE) #> Set-Cookie: xyz=123; Max-Age=3600; HttpOnly          token <- 'randomstring123'     cookie(token) #> Set-Cookie: token=randomstring123          response(cookie(token = 'randomstring123')) #> HTTP/1.1 200 OK #> Set-Cookie: token=randomstring123 #>  #> OK"},{"path":"https://cmmr.github.io/webqueue/reference/header.html","id":null,"dir":"Reference","previous_headings":"","what":"Assemble an HTTP header. — header","title":"Assemble an HTTP header. — header","text":"See https://developer.mozilla.org/en-US/docs/Glossary/Response_header example response headers purpose.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/header.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assemble an HTTP header. — header","text":"","code":"header(..., expose = FALSE, name = ...names(), value = ..1)"},{"path":"https://cmmr.github.io/webqueue/reference/header.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assemble an HTTP header. — header","text":"... single key-value pair. expose Allow javascript read header. name Explicitly set name (key) key-value pair. value Explicitly set value key-value pair.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/header.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assemble an HTTP header. — header","text":"'header' object can passed response().","code":""},{"path":"https://cmmr.github.io/webqueue/reference/header.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assemble an HTTP header. — header","text":"","code":"library(webqueue)          header(name = 'Location', value = '/index.html') #> Location: /index.html          Location <- '/index.html'     header(Location) #> Location: /index.html          response(307L, header(Location = '/index.html')) #> HTTP/1.1 307 Temporary Redirect #> Location: /index.html #>  #> Temporary Redirect          # Allow javascript to access a header value     header('x-user-id' = 100, expose = TRUE) #> x-user-id: 100 #> Access-Control-Expose-Headers: x-user-id"},{"path":"https://cmmr.github.io/webqueue/reference/js_obj.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure a list becomes a JSON object. — js_obj","title":"Ensure a list becomes a JSON object. — js_obj","text":"function returns list jsonlite::toJSON() always encode {}.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/js_obj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure a list becomes a JSON object. — js_obj","text":"","code":"js_obj(x = list())"},{"path":"https://cmmr.github.io/webqueue/reference/js_obj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure a list becomes a JSON object. — js_obj","text":"x list, list-like object.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/js_obj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure a list becomes a JSON object. — js_obj","text":"list names attribute set.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/js_obj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure a list becomes a JSON object. — js_obj","text":"","code":"library(webqueue)          updates <- list()          response(list(updates = updates)) #> HTTP/1.1 200 OK #> Content-Type: application/json; charset=utf-8 #>  #> {\"updates\":[]}          response(list(updates = js_obj(updates))) #> HTTP/1.1 200 OK #> Content-Type: application/json; charset=utf-8 #>  #> {\"updates\":{}}"},{"path":"https://cmmr.github.io/webqueue/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. httpuv randomPort, staticPath, staticPathOptions jobqueue run_now jsonlite fromJSON, toJSON, unbox parallelly availableCores","code":""},{"path":"https://cmmr.github.io/webqueue/reference/response.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile an HTTP response. — response","title":"Compile an HTTP response. — response","text":"WebQueue's handler function returns list, json object, character vector, scalar integer, response() used transform result HTTP response. may also call response() within handler better customize HTTP response. , return result class 'AsIs' object passed directly 'httpuv'.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/response.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile an HTTP response. — response","text":"","code":"response(body = NULL, status = 200L, headers = NULL, ...)"},{"path":"https://cmmr.github.io/webqueue/reference/response.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile an HTTP response. — response","text":"body content. list encoded JSON. scalar integer interpreted status. character vector concatenated separator. status HTTP response status code. headers named character vector HTTP headers. list-like object acceptable elements simple strings. ... Objects created header() /cookie(). key-value pairs add headers.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/response.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile an HTTP response. — response","text":"<response/AsIs> object. Essentially list elements named body, status, headers formatted 'httpuv' expects.","code":""},{"path":"https://cmmr.github.io/webqueue/reference/response.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile an HTTP response. — response","text":"","code":"library(webqueue)          response(list(name = unbox('Peter'), pi = pi)) #> HTTP/1.1 200 OK #> Content-Type: application/json; charset=utf-8 #>  #> {\"name\":\"Peter\",\"pi\":[3.1416]}               response(307L, Location = '/new/file.html') #> HTTP/1.1 307 Temporary Redirect #> Location: /new/file.html #>  #> Temporary Redirect          # The `body` and `status` slots also handle header objects.     response(cookie(id = 123, http_only = TRUE)) #> HTTP/1.1 200 OK #> Set-Cookie: id=123; HttpOnly #>  #> OK          # Allow javascript to access custom headers.     uid <- header('x-user-id'    = 100, expose = TRUE)     sid <- header('x-session-id' = 303, expose = TRUE)     response(uid, sid) #> HTTP/1.1 200 OK #> x-user-id: 100 #> x-session-id: 303 #> Access-Control-Expose-Headers: x-user-id, x-session-id #>  #> OK"}]
